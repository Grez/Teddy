Komunikace v reálném čase

HTTP je bezstavový protokol. Funguje tedy na principu požadavek-odpověď http://tools.ietf.org/html/rfc7230. Bez nového požadavku na server proto není možné uživateli poslat notifikaci o nové události. Abychom překonali tohoto omezení a zpříjemnili používání aplikace lze použít AJAX, které v pravidelných intervalech posílají nové dotazy na server a podle toho upraví část HTML na klientovi. Pro tento způsob komunikace se vžil název heartbeat https://www.zdrojak.cz/clanky/kometa-prinasi-web-v-realnem-case/.

<Obrázek pro heartbeat>

S využitím AJAXu se o nové události klient pravděpodobně nedozví okamžitě, ale až několik sekund nebo spíše desítek sekund po jejím vzniku. Čím rychleji budeme chtít dostat informaci o nové události, tím častěji budeme muset posílat požadavky na server. Jelikož se dá očekávat, že většina požadavků navíc nevyvolá žádné změny na klientovi (většina aplikací nemá pro každého klienta změny každou sekundu), bude tak spousta požadavků zbytečných. To vede k zatěžování serveru a sítě (pro každý požadavek musíme znovu přenášet hlavičky, cookies, server zpracovat požadavek...) Tento problém by šel vyřešit, pokud bychom umožnili serveru posílat notifikace o událostech ke klientovi. Pomocí HTTP to bohužel jednoduše nejde. Klient by musel mít veřejnou IP adresu, povolit na firewallu a další v reálném světě ne úplně lehce požadovatelné kritéria. V dnešní době už ale existuje několik technik, jak toho dosáhnout.

Long-polling (dlouhé dotazování)

<Obrázek pro longpolling>

Long-polling spočívá v tom, že server nechává spojení s klientem otevřené, až do doby, než má pro klienta nějakou odpověd, nebo vyprší maximální čas spojení. Pokud klient dostane zpět nějaká data, zpracuje je. Pokud ne, nebo dojde k přerušení spojení kvůli překročení maximálního limitu, tak klient pošle nový požadavek na server. Díky tomuto server může odeslat notifikace o nových událostech hned, kdy je má k dispozici.

Pro implementaci long-pollingu jde například použít neviditelný <iframe> element.

Server-sent-events (serverem odesílané události)

Long-polling je do jisté míry ohýbání HTTP. Server-sent-events se snaží od tohoto aplikaci odstínit. Implementuje tedy tedy long-polling přímo na úrovni prohlížeče. Aplikace už jednoduše zavolá požadavek na určitou URL adresu a o udržování spojení se stará přímo sám prohlížeč. Máme tak jednoduše vytvořené jednosměrné spojení ze serveru ke klientovi.

Web Sockets

<Obrázek pro Web Sockets>

Pokud chceme obousměrné real-time spojení je potřeba se obrátit už na jiný protokol. Web Sockets umožnuje připojení více klientů na jeden server a okamžitou komunikaci mezi nimi. Uživatel tak jednoduše může odeslat zprávu, kterou server může zpracovat a případně předat dalším klientům.

Shrnutí:
                                LP                   Server Sent Events                Web Sockets
Podpora v prohlížečích:   všechny moderní    |       všechny moderní kromě IE http://caniuse.com/#feat=eventsource    |    všechny moderní http://caniuse.com/#feat=websockets
Náročnost server: nechává otevřené requesty pro každé spojení | stejné jako LP |
Implementace: jednoduchá | ještě jednodušší |
Rychlost:

Web RTC


Porovnání Web Sockets s Web RTC
- Web RTC umožňuje spojení klient-klient, na navázání spojení

___


Web Workers

Pokud programujeme nějakou komplexnější webovou aplikaci, tak je často potřeba vykonávat i nějaké náročnější operace. Tyto operace můžeme provádět buď na serveru, nebo na klientovi. Server bude s velkou pravděpodobností výkonnější než klient, musíme ovšem počítat s potřebným časem pro komunikaci. Většinou navíc každý server obsluhuje větší množství klientů. Pokud bychom vykonávali operace přímo na klientovi, můžeme dosáhnout rychlejší a škálovatelnější aplikace.
V posledních letech došlo k výraznému zrychlení interpretace javascriptu ve všech hlavních prohlížečích. Javascript je stále ovšem jednovláknový jazyk, takže pokud volání funkce trvá příliš dlouho, dojde k zamrznutí stránky (případně celého prohlížeče). Toto je samozřejmě nežádoucí jev, kterému bychom se rádi vyhnuli. Jednou takovou možností jsou Web Workers.
Web Workers je JavaScript, který běží na pozadí, nezávisle na ostatních skriptech, aniž by ovlivňoval výkon samostatné stránky. Na straně uživatele tak nedochází k zamrznutí stránky po dobu průběhu výpočtu a pouze mu zobrazíme výsledek, až nám jej worker pošle. Díky tomu můžeme na klientovi provádět náročnější operace (např. počítání nejkratší cesty v grafu) a uživatel přesto bude mít celou dobu plně funkční aplikaci.
Web Workers se také dají využít k obejití některých omezení prohlížečů. Ku příkladu Google Chrome nedovoluje u neaktivních tabů zavolat funkci `setTimeout` častěji než 1x za sekundu. Pokud bychom pak chtěli zobrazit novou událost například pomocí jednoduché animace měnící titulek stránky, tak nám to nepůjde.
Oba uvedené příklady jsou vyřešené v praktické části této práce.

<webworkers_tabs.png>

https://www.zdrojak.cz/clanky/webdesigneruv-pruvodce-po-html5-multithreading-s-webworkers/
http://www.w3schools.com/html/html5_webworkers.asp
https://blog.pivotal.io/labs/labs/chrome-and-firefox-throttle-settimeout-setinterval-in-inactive-tabs


___

Generování mapy

Perlinův šum

Pokud chceme generovat přirozeně vypadající objekty, potřebujeme nějakou spojitou pseudonáhodnou funkci. Jednou z nich je například Perlinův šum, vytvořený v 80. letech Kenem Perlinem.
Perlinův šum má široké využití v počítačové grafice. Lze pomocí

Šumová funkce je pseudonáhodný generátor čísel.

Šum je tedy funkce mapující nějakou hodnotu R^n do R. Jako vstup použijeme nějaké n-dimenziální souřadnice a dostaneme reálné číslo.

Takovou funkcí je například Perlinův šum vytvořený v 80. letech Kenem Perlinem.

Pseudonáhodná funkce je funkce, která vypadá náhodně, ale ve skutečnosti není. Pro daný vstup vrátí vždy stejný výstup. Pokud budeme chtít vytvořit pomocí takové funkce realisticky vypadající objekt, zjistíme, že vypadá uměle.

Pokud budeme chtít vytvořit přirozeně vypadají objekt neobejdeme se bez nějaké náhodnostní funkce. Budeme

http://freespace.virgin.net/hugo.elias/models/m_perlin.htm
Šum je pseudonáhodná funkce. Vypadá sice náhodně, ale pro určitý vstup vrátí vždy daný výstup.

http://www.noisemachine.com/talk1/14.html


___

Web RTC

Web RTC má tři hlavní komponenty: `getUserMedia`, `RTCPeerConnection`, `RTCDataChannel`

getUserMedia


___

## Modul pro detekci hráčů spravujících více profilů

Každá kompetitivní hra, kde se hráčské profily vzájemně ovlivňují musí nějak ošetřit situaci, kdy by jeden uživatel spravoval více profilů. Hráč by tak totiž jednoduše mohl získat výhodu nad ostatními (jednostranně výhodné obchody, útoky atp.). Možným řešením tohoto problému je například zmenšení lákavosti přímo na úrovni návrhu hry. Může to jednoduše být, že se hráč vždy objeví na náhodném místě na mapě, takže nemůže ovlivňovat svůj druhý profil kvůli vzdálenosti, nebo třeba nepovolíme obchod přímo mezi hráči, ale vytvoříme pouze globální burzu, kde kupující neví, kdo je prodávající apod. Tato opatření ovšem budou omezovat možnosti herního návrhu, proto bychom chtěli mít i možnost odhalovat samotné nepoctivé hráče. V této kapitole se zaměřím na možné způsoby, jak toho dosáhnout.

#### IP adresa

První možností, která se nabízí, je kontrolovat IP adresu. Vzhledem k tomu, že hráči velmi často pochází ze stejných kruhů (školy, kroužky, práce), ovšem musíme počítat s tím, že někteří hráči občas mohou mít stejnou IP adresu. Navíc musíme mít na paměti, že pod IP adresou jednoho telefonního operátora může být více různých hráčů, přestože se nikdy fyzicky nemuseli potkat.

#### Uložit si identifikátor k zařízení

O něco lepší řešení může být snaha identifikovat konkrétní zařízení, ze kterého se hráč přihlašuje. Toho můžeme docílit snadno pomocí cookies. Uložíme si u klienta nějaké náhodné číslo, které si zjistíme vždy, když se bude přihlašovat. Pokud uvidíme, že dva uživatelé měli stejný identifikátor, víme, že se přihlásili ze stejného zařízení.
Tento identifikátor navíc nemusíme uložit pouze do obyčejných HTTP cookie, ale můžeme jej uložit i na spoustu jiných míst, kde je některé prohlížeče nedovolí jednoduše mazat. Flash cookies, HTML5 Local Storage, keš prohlížeče a jiné. Pro usnadnění se dá použít například knihovna https://github.com/samyk/evercookie

#### CSS History Sniffing

// http://arstechnica.com/security/2014/06/theyre-ba-ack-browser-sniffing-ghosts-return-to-haunt-chrome-ie-firefox/

#### Identifikace zařízení pomocí "otisku"

Žádná dvě zařízení připojená k Internetu nejsou identická. Každé se bude lišit minimálně ve své MAC adrese. K té se bohužel nedostaneme, ale i tak máme spoustu dalších znaků, podle kterých se budou stroje uživatelů lišit. User-agent, jazyk, nastavená časová zóna, instalovaná písma, rozlišení, zapnuté pluginy a spoustu dalších informací nám prohlížeč sdělí, pokud si o ně požádáme. Pokud si všechny tyto informace zjistíme a vytvoříme z nich nějaký otisk, tak jsme schopni s velkou pravděpodobností určit prohlížeč jedinečný prohlížeč i bez pomocí cookie. Takto lze odhalit například uživatele, kteří využívají anonymních režimů.
Do praktické části jsem začlenil knihovnu FingerPrint.js, která přesně tento otisk sestavuje.
https://github.com/Valve/fingerprintjs2

#### Heslo uživatele

Mírně kontroverzní, avšak velmi účinnou metodou na odhalování hráčů s více profily může být také podívat se na jejich hesla. Významná část uživatelů používá pouze jedno heslo na všech stránkách. Pokud bude mít více hráčů stejné, tak je možné, že se ve skutečnosti jedná o jednu osobu.
Samozřejmě toto může být značně kontroverzní, vzhledem k možným dopadům při uniknutí dat z databáze. Ukládat hesla jako prostý text by tedy bylo velice nepraktické. Rozumný kompromis by ovšem mohl být používat jednotnou "sůl" při hashování hesel, tak aby případný útočník nevěděl o jaké heslo se jedná, ale zároveň bychom byli schopni odhalovat podvádějící hráče.

### Validace pomocí třetí strany

